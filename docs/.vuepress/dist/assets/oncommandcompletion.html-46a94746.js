import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as r,c as s,d as e,b as a,w as o,e as t,f as c}from"./app-45f7c304.js";const l={},h=c(`<h1 id="oncommandcompletion-events" tabindex="-1"><a class="header-anchor" href="#oncommandcompletion-events" aria-hidden="true">#</a> <code>onCommandCompletion</code> - events</h1><blockquote><p>Trigger an event upon a command&#39;s completion</p></blockquote><h2 id="description" tabindex="-1"><a class="header-anchor" href="#description" aria-hidden="true">#</a> Description</h2><p><code>onCommandCompletion</code> events are triggered after a command has finished executing in the interactive terminal.</p><p>Background processes or commands ran from inside aliases, functions, nested blocks or from shell scripts cannot trigger this event. This is to protect against accidental race conditions, infinite loops and breaking expected behaviour / the portability of Murex scripts. On those processes directly ran from the prompt can trigger this event.</p><h2 id="usage" tabindex="-1"><a class="header-anchor" href="#usage" aria-hidden="true">#</a> Usage</h2><pre><code>event: onCommandCompletion name=command { code block }

!event: onCommandCompletion name
</code></pre><h2 id="valid-interrupts" tabindex="-1"><a class="header-anchor" href="#valid-interrupts" aria-hidden="true">#</a> Valid Interrupts</h2><ul><li><code>&lt;command&gt;</code> Name of command that triggers this event</li></ul><h2 id="examples" tabindex="-1"><a class="header-anchor" href="#examples" aria-hidden="true">#</a> Examples</h2><p><strong>Read STDERR:</strong></p><p>In this example we check the output from <code>pacman</code>, which is ArchLinux&#39;s package management tool, to see if you have accidentally ran it as a non-root user. If the STDERR contains a message saying you are no root, then this event function will re-run <code>pacman</code> with <code>sudo</code>.</p><pre><code>event: onCommandCompletion sudo-pacman=pacman {
    \`&lt;stdin&gt;\` -&gt; set event
    read-named-pipe: $event.Interrupt.Stderr \\
    -&gt; regexp &#39;m/error: you cannot perform this operation unless you are root/&#39; \\
    -&gt; if {
          sudo pacman @event.Interrupt.Parameters
       }
}
</code></pre><h2 id="detail" tabindex="-1"><a class="header-anchor" href="#detail" aria-hidden="true">#</a> Detail</h2><h3 id="payload" tabindex="-1"><a class="header-anchor" href="#payload" aria-hidden="true">#</a> Payload</h3><p>The following payload is passed to the function via STDIN:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    {
        &quot;Name&quot;: &quot;&quot;,
        &quot;Interrupt&quot;: {
            &quot;Command&quot;: &quot;&quot;,
            &quot;Parameters&quot;: [],
            &quot;Stdout&quot;: &quot;&quot;,
            &quot;Stderr&quot;: &quot;&quot;,
            &quot;ExitNum&quot;: 0
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="name" tabindex="-1"><a class="header-anchor" href="#name" aria-hidden="true">#</a> Name</h4><p>This is the name you specified when defining the event.</p><h4 id="command" tabindex="-1"><a class="header-anchor" href="#command" aria-hidden="true">#</a> Command</h4><p>Name of command executed prior to this event being triggered</p><h4 id="operation" tabindex="-1"><a class="header-anchor" href="#operation" aria-hidden="true">#</a> Operation</h4><p>The commandline parameters of the aforementioned command</p><h4 id="stdout" tabindex="-1"><a class="header-anchor" href="#stdout" aria-hidden="true">#</a> Stdout</h4><p>This is the name of the Murex named pipe which contains a copy of the STDOUT from the command which executed prior to this event.</p><p>You can read this with <code>read-named-pipe</code>. eg</p><pre><code>» \`&lt;stdin&gt;\` -&gt; set: event
» read-named-pipe: $event.Interrupt.Stdout -&gt; ...
</code></pre><h4 id="stderr" tabindex="-1"><a class="header-anchor" href="#stderr" aria-hidden="true">#</a> Stderr</h4><p>This is the name of the Murex named pipe which contains a copy of the STDERR from the command which executed prior to this event.</p><p>You can read this with <code>read-named-pipe</code>. eg</p><pre><code>» \`&lt;stdin&gt;\` -&gt; set: event
» read-named-pipe: $event.Interrupt.Stderr -&gt; ...
</code></pre><h4 id="exitnum" tabindex="-1"><a class="header-anchor" href="#exitnum" aria-hidden="true">#</a> ExitNum</h4><p>This is the exit number returned from the executed command.</p><h3 id="stdout-1" tabindex="-1"><a class="header-anchor" href="#stdout-1" aria-hidden="true">#</a> Stdout</h3><p>Stdout is written to the terminal. So this can be used to provide multiple additional lines to the prompt since readline only supports one line for the prompt itself and three extra lines for the hint text.</p><h2 id="see-also" tabindex="-1"><a class="header-anchor" href="#see-also" aria-hidden="true">#</a> See Also</h2>`,36),m=e("code",null,"<stdin>",-1),u=e("code",null,"alias",-1),p=e("code",null,"config",-1),f=e("code",null,"event",-1),v=e("code",null,"function",-1),g=e("code",null,"if",-1),x=e("code",null,"onPrompt",-1),b=e("code",null,"regexp",-1);function _(q,y){const n=d("RouterLink");return r(),s("div",null,[h,e("ul",null,[e("li",null,[a(n,{to:"/user-guide/namedpipes.html"},{default:o(()=>[t("Murex Named Pipes")]),_:1}),t(": A detailed breakdown of named pipes in Murex")]),e("li",null,[a(n,{to:"/commands/stdin.html"},{default:o(()=>[m]),_:1}),t(": Read the STDIN belonging to the parent code block")]),e("li",null,[a(n,{to:"/commands/alias.html"},{default:o(()=>[u]),_:1}),t(": Create an alias for a command")]),e("li",null,[a(n,{to:"/commands/config.html"},{default:o(()=>[p]),_:1}),t(": Query or define Murex runtime settings")]),e("li",null,[a(n,{to:"/commands/event.html"},{default:o(()=>[f]),_:1}),t(": Event driven programming for shell scripts")]),e("li",null,[a(n,{to:"/commands/function.html"},{default:o(()=>[v]),_:1}),t(": Define a function block")]),e("li",null,[a(n,{to:"/commands/if.html"},{default:o(()=>[g]),_:1}),t(": Conditional statement to execute different blocks of code depending on the result of the condition")]),e("li",null,[a(n,{to:"/events/onprompt.html"},{default:o(()=>[x]),_:1}),t(": Events triggered by changes in state of the interactive shell")]),e("li",null,[a(n,{to:"/commands/regexp.html"},{default:o(()=>[b]),_:1}),t(": Regexp tools for arrays / lists of strings")]),e("li",null,[a(n,{to:"/commands/namedpipe.html"},{default:o(()=>[t("read-named-pipe")]),_:1}),t(": Reads from a Murex named pipe")])])])}const w=i(l,[["render",_],["__file","oncommandcompletion.html.vue"]]);export{w as default};
